import { z } from 'zod';
import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import fs from 'fs/promises';
import type { OperationBatch } from '@n8n-ai/schemas';

const execAsync = promisify(exec);

// Git configuration schema
export const GitConfigSchema = z.object({
  enabled: z.boolean().default(false),
  repoPath: z.string(),
  branch: z.string().default('main'),
  remote: z.string().default('origin'),
  author: z.object({
    name: z.string(),
    email: z.string(),
  }),
  pullRequest: z.object({
    enabled: z.boolean().default(true),
    baseBranch: z.string().default('main'),
    provider: z.enum(['github', 'gitlab', 'bitbucket']).default('github'),
    assignees: z.array(z.string()).optional(),
    reviewers: z.array(z.string()).optional(),
    labels: z.array(z.string()).optional(),
  }).optional(),
});

export type GitConfig = z.infer<typeof GitConfigSchema>;

// Git operation result
export interface GitOperationResult {
  success: boolean;
  commitHash?: string;
  branch?: string;
  pullRequestUrl?: string;
  diffUrl?: string;
  error?: string;
}

export class GitIntegration {
  constructor(private config: GitConfig) {}
  
  /**
   * Create a commit from an operation batch
   */
  async createCommit(
    workflowId: string,
    workflowName: string,
    batch: OperationBatch,
    context: {
      userId?: string;
      prompt?: string;
      description?: string;
    }
  ): Promise<GitOperationResult> {
    try {
      // Ensure we're in the right directory
      process.chdir(this.config.repoPath);
      
      // Create a unique branch name
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const branchName = `ai-workflow-${workflowId}-${timestamp}`;
      
      // Create and checkout new branch
      await execAsync(`git checkout -b ${branchName}`);
      
      // Export workflow to file
      const workflowFile = path.join(
        this.config.repoPath,
        'workflows',
        `${workflowId}.json`
      );
      
      // Get the updated workflow (mock - replace with actual)
      const updatedWorkflow = await this.getUpdatedWorkflow(workflowId);
      
      // Ensure directory exists
      await fs.mkdir(path.dirname(workflowFile), { recursive: true });
      
      // Write workflow file
      await fs.writeFile(
        workflowFile,
        JSON.stringify(updatedWorkflow, null, 2)
      );
      
      // Stage the file
      await execAsync(`git add ${workflowFile}`);
      
      // Create commit message
      const commitMessage = this.buildCommitMessage(
        workflowName,
        batch,
        context
      );
      
      // Set author
      await execAsync(
        `git -c user.name="${this.config.author.name}" ` +
        `-c user.email="${this.config.author.email}" ` +
        `commit -m "${commitMessage}"`
      );
      
      // Get commit hash
      const { stdout: commitHash } = await execAsync('git rev-parse HEAD');
      
      // Push branch
      await execAsync(`git push ${this.config.remote} ${branchName}`);
      
      // Create pull request if enabled
      let pullRequestUrl: string | undefined;
      if (this.config.pullRequest?.enabled) {
        pullRequestUrl = await this.createPullRequest(
          branchName,
          workflowName,
          batch,
          context
        );
      }
      
      // Generate diff URL
      const diffUrl = this.generateDiffUrl(branchName, commitHash.trim());
      
      return {
        success: true,
        commitHash: commitHash.trim(),
        branch: branchName,
        pullRequestUrl,
        diffUrl,
      };
      
    } catch (error) {
      console.error('Git operation failed:', error);
      
      // Try to clean up
      try {
        await execAsync(`git checkout ${this.config.branch}`);
      } catch {}
      
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Git operation failed',
      };
    }
  }
  
  /**
   * Build commit message from operation batch
   */
  private buildCommitMessage(
    workflowName: string,
    batch: OperationBatch,
    context: any
  ): string {
    const operationSummary = this.summarizeOperations(batch);
    
    let message = `feat(workflow): Update ${workflowName}\n\n`;
    
    if (context.prompt) {
      message += `AI Prompt: ${context.prompt}\n\n`;
    }
    
    message += `Changes:\n${operationSummary}\n\n`;
    
    if (context.description) {
      message += `${context.description}\n\n`;
    }
    
    message += `Generated by: AI Workflow Builder\n`;
    if (context.userId) {
      message += `User: ${context.userId}\n`;
    }
    
    return message;
  }
  
  /**
   * Summarize operations for commit message
   */
  private summarizeOperations(batch: OperationBatch): string {
    const summary: string[] = [];
    const opCounts: Record<string, number> = {};
    
    // Count operations
    for (const op of batch.ops) {
      opCounts[op.op] = (opCounts[op.op] || 0) + 1;
    }
    
    // Build summary
    if (opCounts.add_node) {
      summary.push(`- Added ${opCounts.add_node} node(s)`);
    }
    if (opCounts.connect) {
      summary.push(`- Created ${opCounts.connect} connection(s)`);
    }
    if (opCounts.set_params) {
      summary.push(`- Updated ${opCounts.set_params} node parameter(s)`);
    }
    if (opCounts.delete) {
      summary.push(`- Removed ${opCounts.delete} node(s)`);
    }
    if (opCounts.annotate) {
      summary.push(`- Added ${opCounts.annotate} annotation(s)`);
    }
    
    return summary.join('\n');
  }
  
  /**
   * Create pull request (GitHub example)
   */
  private async createPullRequest(
    branchName: string,
    workflowName: string,
    batch: OperationBatch,
    context: any
  ): Promise<string | undefined> {
    if (this.config.pullRequest?.provider !== 'github') {
      // Only GitHub implemented for now
      return undefined;
    }
    
    try {
      // Get repository info
      const { stdout: remoteUrl } = await execAsync(
        `git config --get remote.${this.config.remote}.url`
      );
      
      const repoInfo = this.parseGitHubUrl(remoteUrl.trim());
      if (!repoInfo) return undefined;
      
      // Create PR using GitHub CLI if available
      const prTitle = `Update workflow: ${workflowName}`;
      const prBody = this.buildPullRequestBody(workflowName, batch, context);
      
      const { stdout: prUrl } = await execAsync(
        `gh pr create ` +
        `--title "${prTitle}" ` +
        `--body "${prBody}" ` +
        `--base ${this.config.pullRequest.baseBranch} ` +
        `--head ${branchName}`
      );
      
      return prUrl.trim();
      
    } catch (error) {
      console.error('Failed to create pull request:', error);
      return undefined;
    }
  }
  
  /**
   * Build pull request body
   */
  private buildPullRequestBody(
    workflowName: string,
    batch: OperationBatch,
    context: any
  ): string {
    let body = `## AI-Generated Workflow Update\n\n`;
    body += `**Workflow**: ${workflowName}\n\n`;
    
    if (context.prompt) {
      body += `### AI Prompt\n\`\`\`\n${context.prompt}\n\`\`\`\n\n`;
    }
    
    body += `### Changes Summary\n`;
    body += this.summarizeOperations(batch) + '\n\n';
    
    body += `### Operation Details\n`;
    body += `<details>\n<summary>View full operation batch</summary>\n\n`;
    body += `\`\`\`json\n${JSON.stringify(batch, null, 2)}\n\`\`\`\n`;
    body += `</details>\n\n`;
    
    body += `### Validation\n`;
    body += `- [ ] Workflow syntax validated\n`;
    body += `- [ ] Connections verified\n`;
    body += `- [ ] Parameters checked\n`;
    body += `- [ ] Tested in development\n\n`;
    
    if (this.config.pullRequest?.reviewers?.length) {
      body += `### Reviewers\n`;
      body += this.config.pullRequest.reviewers
        .map(r => `- @${r}`)
        .join('\n') + '\n\n';
    }
    
    return body;
  }
  
  /**
   * Parse GitHub repository URL
   */
  private parseGitHubUrl(url: string): { owner: string; repo: string } | null {
    const patterns = [
      /github\.com[:/]([^/]+)\/([^/.]+)(\.git)?$/,
      /git@github\.com:([^/]+)\/([^/.]+)(\.git)?$/,
    ];
    
    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) {
        return {
          owner: match[1],
          repo: match[2],
        };
      }
    }
    
    return null;
  }
  
  /**
   * Generate diff URL for the commit
   */
  private generateDiffUrl(branch: string, commitHash: string): string {
    // This would vary by provider
    if (this.config.pullRequest?.provider === 'github') {
      const remoteUrl = execSync(
        `git config --get remote.${this.config.remote}.url`
      ).toString();
      
      const repoInfo = this.parseGitHubUrl(remoteUrl.trim());
      if (repoInfo) {
        return `https://github.com/${repoInfo.owner}/${repoInfo.repo}/commit/${commitHash}`;
      }
    }
    
    return '';
  }
  
  /**
   * Get updated workflow (mock implementation)
   */
  private async getUpdatedWorkflow(workflowId: string): Promise<any> {
    // TODO: Fetch actual workflow from n8n
    return {
      id: workflowId,
      name: 'Updated Workflow',
      nodes: [],
      connections: {},
      settings: {},
      staticData: null,
      tags: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
  }
}

// Factory function
export function createGitIntegration(config?: Partial<GitConfig>): GitIntegration | null {
  const gitEnabled = process.env.GIT_INTEGRATION_ENABLED === 'true';
  
  if (!gitEnabled) {
    return null;
  }
  
  const fullConfig: GitConfig = {
    enabled: true,
    repoPath: process.env.GIT_REPO_PATH || process.cwd(),
    branch: process.env.GIT_BRANCH || 'main',
    remote: process.env.GIT_REMOTE || 'origin',
    author: {
      name: process.env.GIT_AUTHOR_NAME || 'AI Workflow Builder',
      email: process.env.GIT_AUTHOR_EMAIL || 'ai@n8n.local',
    },
    pullRequest: {
      enabled: process.env.GIT_PR_ENABLED !== 'false',
      baseBranch: process.env.GIT_PR_BASE || 'main',
      provider: (process.env.GIT_PROVIDER as any) || 'github',
      assignees: process.env.GIT_PR_ASSIGNEES?.split(','),
      reviewers: process.env.GIT_PR_REVIEWERS?.split(','),
      labels: process.env.GIT_PR_LABELS?.split(','),
    },
    ...config,
  };
  
  return new GitIntegration(fullConfig);
}

// Export for the exec function
import { execSync } from 'child_process';